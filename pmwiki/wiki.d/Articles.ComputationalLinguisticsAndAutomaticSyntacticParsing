version=pmwiki-2.2.130 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
author=Kushal_D
charset=UTF-8
csum=
ctime=1620423914
host=74.109.198.171
name=Articles.ComputationalLinguisticsAndAutomaticSyntacticParsing
rev=1
targets=GradebookArticles.ComputationalLinguisticsAndAutomaticSyntacticParsing,Articles.ComputationalLinguisticsAndAutomaticSyntacticParsing,Category.Varia
text=(:if authgroup @tas:)%0a%0a(:toggle id=gi show="show grading interface" hide="hide grading interface":)%0a%0a>>id=gi%3c%3c%0a%0a[[GradebookArticles.{$Name}|See article in gradebook]] \\%0a[[{$FullName}?action=diff|See all changes to article]]%0a%0a(:foxform Site.FoxForms#gradeitem:)%0a%0a(:foxform Site.FoxForms#gradingcomment:)%0a%0a>>%3c%3c%0a%0a----%0a%0a(:ifend:)%0a%0a[[!Varia]]%0a%0a!Computational Linguistics and Automatic Syntactic Parsing%0a%0a:Author: Kushal_D%0a%0a'''Summary:''' \\%0a%0a[[#summary]]%0a%0aA brief explanation for how computers can form parse trees for a sentence%0a%0a[[#summaryends]]%0a%0a----%0a[[#content]]%0a%0aIn class, we learned about syntactic structure and how sentences can be represented in syntax trees. Since this generally involves using a set of phrase structure rules, which are fairly well defined, one would think that getting a computer to figure out which rules need to be applied should be straightforward. It turns out that it's a bit more complicated than one would originally consider, but research has been done on algorithms that can solve this efficiently. The best, as far as I am aware, is a robust algorithm - meaning it will always produce a valid solution - was actually developed by cmu professors[1]. I thought I would summarize the algorithm and explain how it solves common issues that would arise from a naive approach. %0a%0aThe naive approach is to go through all adjacent words try to figure out which PSR rules can be applied to them, and then build up the tree from the bottom-up. However, this algorithm fails when there are multiple possible series of rules that could be applied to arrive at a sentence. The workaround to this, is to run through the sentence 3 times - the first time, you group together every possible group of adjacent words that make grammatical sense (according to our PSR). The second pass, you assign a cost to each substring of words based on the number of rules that need to be applied to parse that substring. Finally, count the number of parses with minimal costs. This algorithm is a bti confusing, in terms of why you need to keep track of the costs, but it is essentially to ensure we look at all possible syntactic trees that could be formed and choose the "best" one. %0a%0aThe result is a pretty effective automatic parser! You can even try it out online here:%0a%0ahttps://www.link.cs.cmu.edu/link/submit-sentence-4.html%0a%0aBibliography:%0aDennis Grinberg, John Lafferty and Daniel Sleator. 1995. A robust parsing algorithm for link grammars. Carnegie Mellon University Computer Science technical report CMU-CS-95-125, and Proceedings of the Fourth International Workshop on Parsing Technologies, Prague, September, 1995.%0a%0a[[#contentends]]%0a----%0a----%0a%0a!!Expansions:%0a[[#expansions]]%0a%0a[[#expansionsend]]%0a%0a----%0a%25red%25 '''Add an expansion:'''%0a%0a(:if [ exists GradebookExpansions.{$Name}-{$Author} || equal {$Author} {$:Author} ] :)%0a%0a(:else:)%0a%0a(:foxform Site.FoxForms#newexpansion:)%0a%0a(:ifend:)%0a%0a----%0a----%0a%0a!!Comments%0a%0a%0a%0a(:section: B:)%0a(:Category: Varia:)
time=1620423914
author:1620423914=Kushal_D
diff:1620423914:1620423914:=1,76d0%0a%3c (:if authgroup @tas:)%0a%3c %0a%3c (:toggle id=gi show="show grading interface" hide="hide grading interface":)%0a%3c %0a%3c >>id=gi%3c%3c%0a%3c %0a%3c [[GradebookArticles.{$Name}|See article in gradebook]] \\%0a%3c [[{$FullName}?action=diff|See all changes to article]]%0a%3c %0a%3c (:foxform Site.FoxForms#gradeitem:)%0a%3c %0a%3c (:foxform Site.FoxForms#gradingcomment:)%0a%3c %0a%3c >>%3c%3c%0a%3c %0a%3c ----%0a%3c %0a%3c (:ifend:)%0a%3c %0a%3c [[!Varia]]%0a%3c %0a%3c !Computational Linguistics and Automatic Syntactic Parsing%0a%3c %0a%3c :Author: Kushal_D%0a%3c %0a%3c '''Summary:''' \\%0a%3c %0a%3c [[#summary]]%0a%3c %0a%3c A brief explanation for how computers can form parse trees for a sentence%0a%3c %0a%3c [[#summaryends]]%0a%3c %0a%3c ----%0a%3c [[#content]]%0a%3c %0a%3c In class, we learned about syntactic structure and how sentences can be represented in syntax trees. Since this generally involves using a set of phrase structure rules, which are fairly well defined, one would think that getting a computer to figure out which rules need to be applied should be straightforward. It turns out that it's a bit more complicated than one would originally consider, but research has been done on algorithms that can solve this efficiently. The best, as far as I am aware, is a robust algorithm - meaning it will always produce a valid solution - was actually developed by cmu professors[1]. I thought I would summarize the algorithm and explain how it solves common issues that would arise from a naive approach. %0a%3c %0a%3c The naive approach is to go through all adjacent words try to figure out which PSR rules can be applied to them, and then build up the tree from the bottom-up. However, this algorithm fails when there are multiple possible series of rules that could be applied to arrive at a sentence. The workaround to this, is to run through the sentence 3 times - the first time, you group together every possible group of adjacent words that make grammatical sense (according to our PSR). The second pass, you assign a cost to each substring of words based on the number of rules that need to be applied to parse that substring. Finally, count the number of parses with minimal costs. This algorithm is a bti confusing, in terms of why you need to keep track of the costs, but it is essentially to ensure we look at all possible syntactic trees that could be formed and choose the "best" one. %0a%3c %0a%3c The result is a pretty effective automatic parser! You can even try it out online here:%0a%3c %0a%3c https://www.link.cs.cmu.edu/link/submit-sentence-4.html%0a%3c %0a%3c Bibliography:%0a%3c Dennis Grinberg, John Lafferty and Daniel Sleator. 1995. A robust parsing algorithm for link grammars. Carnegie Mellon University Computer Science technical report CMU-CS-95-125, and Proceedings of the Fourth International Workshop on Parsing Technologies, Prague, September, 1995.%0a%3c %0a%3c [[#contentends]]%0a%3c ----%0a%3c ----%0a%3c %0a%3c !!Expansions:%0a%3c [[#expansions]]%0a%3c %0a%3c [[#expansionsend]]%0a%3c %0a%3c ----%0a%3c %25red%25 '''Add an expansion:'''%0a%3c %0a%3c (:if [ exists GradebookExpansions.{$Name}-{$Author} || equal {$Author} {$:Author} ] :)%0a%3c %0a%3c (:else:)%0a%3c %0a%3c (:foxform Site.FoxForms#newexpansion:)%0a%3c %0a%3c (:ifend:)%0a%3c %0a%3c ----%0a%3c ----%0a%3c %0a%3c !!Comments%0a%3c %0a%3c %0a%3c %0a%3c (:section: B:)%0a%3c (:Category: Varia:)%0a\ No newline at end of file%0a
host:1620423914=74.109.198.171
