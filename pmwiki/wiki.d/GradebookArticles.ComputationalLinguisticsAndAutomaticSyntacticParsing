version=pmwiki-2.2.130 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
author=TA_audrey
charset=UTF-8
csum=
ctime=1620423914
host=69.218.234.170
name=GradebookArticles.ComputationalLinguisticsAndAutomaticSyntacticParsing
rev=2
targets=
text=:Category: Varia%0a:Essential: {Category.Varia$:essential}%0a:Title: Computational Linguistics and Automatic Syntactic Parsing%0a:Author: Kushal_D%0a:Section: B%0a:Completed: 07.05.2021 - 14:45%0a:Status: complete%0a%0a(:foxform Site.FoxForms#gradeitem:)%0a(:foxform Site.FoxForms#gradingcomment:)%0a%0a----%0a%0a%0a%25blue%25 '''Grading History'''%0a%0a[[#history]]%0a#foxbegin 210511-233616-813200#%0a* [-11.05.2021 - 16:36-] || TA_audrey marked as complete%0a#foxend 210511-233616-813200#%0a[[#historyend]]%0a%0a%25blue%25 '''Comments for student'''%0a%0a[[#comments]]%0a%0a[[#commentsend]]%0a%0a----%0a----%0a!!%0a%0aSummary: \\%0a%0a[[#summary]]%0a%0aA brief explanation for how computers can form parse trees for a sentence%0a%0a[[#summaryends]]%0a%0a----%0a[[#content]]%0a%0aIn class, we learned about syntactic structure and how sentences can be represented in syntax trees. Since this generally involves using a set of phrase structure rules, which are fairly well defined, one would think that getting a computer to figure out which rules need to be applied should be straightforward. It turns out that it's a bit more complicated than one would originally consider, but research has been done on algorithms that can solve this efficiently. The best, as far as I am aware, is a robust algorithm - meaning it will always produce a valid solution - was actually developed by cmu professors[1]. I thought I would summarize the algorithm and explain how it solves common issues that would arise from a naive approach. %0a%0aThe naive approach is to go through all adjacent words try to figure out which PSR rules can be applied to them, and then build up the tree from the bottom-up. However, this algorithm fails when there are multiple possible series of rules that could be applied to arrive at a sentence. The workaround to this, is to run through the sentence 3 times - the first time, you group together every possible group of adjacent words that make grammatical sense (according to our PSR). The second pass, you assign a cost to each substring of words based on the number of rules that need to be applied to parse that substring. Finally, count the number of parses with minimal costs. This algorithm is a bti confusing, in terms of why you need to keep track of the costs, but it is essentially to ensure we look at all possible syntactic trees that could be formed and choose the "best" one. %0a%0aThe result is a pretty effective automatic parser! You can even try it out online here:%0a%0ahttps://www.link.cs.cmu.edu/link/submit-sentence-4.html%0a%0aBibliography:%0aDennis Grinberg, John Lafferty and Daniel Sleator. 1995. A robust parsing algorithm for link grammars. Carnegie Mellon University Computer Science technical report CMU-CS-95-125, and Proceedings of the Fourth International Workshop on Parsing Technologies, Prague, September, 1995.%0a%0a[[#contentends]]%0a----%0a(:GradedBy: TA_audrey:)
time=1620776175
author:1620776175=TA_audrey
diff:1620776175:1620423914:=7,8c7,8%0a%3c :Status: complete%0a%3c %0a---%0a> :Status: ungraded%0a> %0a18,20c18%0a%3c #foxbegin 210511-233616-813200#%0a%3c * [-11.05.2021 - 16:36-] || TA_audrey marked as complete%0a%3c #foxend 210511-233616-813200#%0a---%0a> %0a56,57c54%0a%3c ----%0a%3c (:GradedBy: TA_audrey:)%0a\ No newline at end of file%0a---%0a> ----%0a\ No newline at end of file%0a
host:1620776175=69.218.234.170
author:1620423914=Kushal_D
diff:1620423914:1620423914:=1,54d0%0a%3c :Category: Varia%0a%3c :Essential: {Category.Varia$:essential}%0a%3c :Title: Computational Linguistics and Automatic Syntactic Parsing%0a%3c :Author: Kushal_D%0a%3c :Section: B%0a%3c :Completed: 07.05.2021 - 14:45%0a%3c :Status: ungraded%0a%3c %0a%3c (:foxform Site.FoxForms#gradeitem:)%0a%3c (:foxform Site.FoxForms#gradingcomment:)%0a%3c %0a%3c ----%0a%3c %0a%3c %0a%3c %25blue%25 '''Grading History'''%0a%3c %0a%3c [[#history]]%0a%3c %0a%3c [[#historyend]]%0a%3c %0a%3c %25blue%25 '''Comments for student'''%0a%3c %0a%3c [[#comments]]%0a%3c %0a%3c [[#commentsend]]%0a%3c %0a%3c ----%0a%3c ----%0a%3c !!%0a%3c %0a%3c Summary: \\%0a%3c %0a%3c [[#summary]]%0a%3c %0a%3c A brief explanation for how computers can form parse trees for a sentence%0a%3c %0a%3c [[#summaryends]]%0a%3c %0a%3c ----%0a%3c [[#content]]%0a%3c %0a%3c In class, we learned about syntactic structure and how sentences can be represented in syntax trees. Since this generally involves using a set of phrase structure rules, which are fairly well defined, one would think that getting a computer to figure out which rules need to be applied should be straightforward. It turns out that it's a bit more complicated than one would originally consider, but research has been done on algorithms that can solve this efficiently. The best, as far as I am aware, is a robust algorithm - meaning it will always produce a valid solution - was actually developed by cmu professors[1]. I thought I would summarize the algorithm and explain how it solves common issues that would arise from a naive approach. %0a%3c %0a%3c The naive approach is to go through all adjacent words try to figure out which PSR rules can be applied to them, and then build up the tree from the bottom-up. However, this algorithm fails when there are multiple possible series of rules that could be applied to arrive at a sentence. The workaround to this, is to run through the sentence 3 times - the first time, you group together every possible group of adjacent words that make grammatical sense (according to our PSR). The second pass, you assign a cost to each substring of words based on the number of rules that need to be applied to parse that substring. Finally, count the number of parses with minimal costs. This algorithm is a bti confusing, in terms of why you need to keep track of the costs, but it is essentially to ensure we look at all possible syntactic trees that could be formed and choose the "best" one. %0a%3c %0a%3c The result is a pretty effective automatic parser! You can even try it out online here:%0a%3c %0a%3c https://www.link.cs.cmu.edu/link/submit-sentence-4.html%0a%3c %0a%3c Bibliography:%0a%3c Dennis Grinberg, John Lafferty and Daniel Sleator. 1995. A robust parsing algorithm for link grammars. Carnegie Mellon University Computer Science technical report CMU-CS-95-125, and Proceedings of the Fourth International Workshop on Parsing Technologies, Prague, September, 1995.%0a%3c %0a%3c [[#contentends]]%0a%3c ----%0a\ No newline at end of file%0a
host:1620423914=74.109.198.171
